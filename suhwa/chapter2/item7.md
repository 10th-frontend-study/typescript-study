### 이번 item에서 알아볼 것

코드가 실행되기 전, 즉 타입스크립트가 오류를 체크하는 순간에는 ‘타입’을 가진다.

이러한 ‘할당 가능한 값들의 집합’을 타입의 ‘범위’라고 한다.

이번 장에서는 타입이 값들의 집합이라는 것의 개념을 이해하도록 한다.

---

### 타입은 할당가능한 값들의 집합이고, 이러한 집합은 타입의 범위이다.

타입의 범위는 값의 개수에 따라 총 3개로 나눌 수 있다.

1. 값이 없다 : never 타입
2. 값이 1개이다 : unit 타입 / literal 타입

   `**type A = ‘A’;**`

3. 값이 2개 이상이다 : union 타입 ( `| 연산자`를 사용해서 타입을 묶는다.)

   `**type AB = ‘A’ | ‘B’;**`

### &연산자 (교차 타입 생성)

- 타입스크립트의 &연산자는 교차 타입을 생성한다.
- 교차 타입은 여러 타입을 하나로 결합하여 모든 타입의 멤버를 가진 새로운 타입을 만든다.

```jsx
interface Person {
  name: string;
}

interface Lifespan {
  birth: Date;
  death?: Date;
}

type PersonSpan = Person & Lifespan;
const ps: PersonSpan = {
  name: "Alan Turing",
  birth: new Date("1912/06/23"),
  death: new Date("1954/06/07"),
}; // OK
```

- 위에서 Person 타입과 Lifespan 타입을 하나로 묶은 PersonSpan 타입이 생성되었다.

### 타입이 **값의 집합**이라는 것의 의미

- 동일한 값의 집합을 가지는 두 타입은 같다는 의미이다.
- 두 개의 타입이 의미적으로 다르고, 우연히 같은 범위를 가지더라도 같은 타입을 두 번 정의할 이유는 없다.

타입스크립트 용어와 집합 용어

| 타입스크립트 용어   | 집합 용어          |
| ------------------- | ------------------ | ---------------- |
| never               | 공집합             |
| 리터럴 타입         | 원소가 1개인 집합  |
| 값이 T에 할당 가능  | 값이 T의 원소      |
| T1이 T2에 할당 가능 | T1이 T2의 부분집합 |
| T1이 T2를 상속      | T1이 T2의 부분집합 |
| T1                  | T2 (유니온)        | T1 U T2 (합집합) |
| T1 & T2 (인터섹션)  | 교집합             |
| unknown             | 전체 집합          |

---

### 요약

1. 타입을 값의 집합으로 생각하면 이해하기 편하다. 이 집합은 무한하거나 유한하다. 무한한 것은 number, string이고, 유한한 것은 boolean, literal이다.
2. 타입스크립트 타입은 엄격한 상속관계가 아니라 겹쳐지는 집합으로 표현된다. (벤다이어그램)
3. 한 객체의 추가적인 속성이 타입 선언에 언급되지 않더라도 그 타입에 속할 수 있다.
4. 타입 연산은 집합의 범위에 적용된다. A와 B의 인터섹션은 A의 범위와 B의 범위의 인터섹션이다. 객체 타입에서는 A & B인 값이 A와 B의 속성을 모두 가짐을 의미한다.
5. ‘A는 B를 상속’, ‘A는 B에 할당 가능’, ‘A는 B의 서브타입’은 ‘A는 B의 부분집합’과 같은 의미이다.

---

### 추가 정리

### 값 vs 타입

- 값

  - 프로그램이 처리하는 실제 데이터
  - 숫자, 문자열, 객체, 함수 등이 있다.

- 타입
  - 해당 값이 어떤 종류의 데이터인지를 설명하는 메타데이터

```jsx
let x: string = "hello";
```

- 여기서 `string`은 `타입`, `hello`는 `값`이다.

### keyof 연산

- 객체 타입의 모든 키를 문자열 리터럴 타입의 유니온으로 추출하는데 사용된다.

```jsx
interface Person {
	name: string;
	age: number;
}

type PersonKeys = keyof Person; // 'name' | 'age'
```
